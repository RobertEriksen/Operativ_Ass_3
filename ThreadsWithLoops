#include <semaphore.h>
#include <pthread.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <time.h>
#include <stdbool.h>

sem_t orderSem;
sem_t writerSem;
sem_t readerSem;

unsigned int readers = 0;

int counter = 0;

struct args {
    int totalIterations;
    int semaOn;
    char* fileName;
};

void readCounter(){
    printf("Reading Counter: %d\n", counter);
}

void* Read(void *input){

    usleep(rand()/100000);

    int semaOn = ((struct args*)input)->semaOn;
    if(semaOn){sem_wait(&orderSem);}
    if(semaOn){sem_wait(&readerSem);}
    if (readers == 0){
        if(semaOn){sem_wait(&writerSem);}
    }
    readers++;
    if(semaOn){sem_post(&orderSem);}
    if(semaOn){sem_post(&readerSem);}

    readCounter();

    if(semaOn){sem_wait(&readerSem);}
    readers--;               
    if (readers == 0){        
        if(semaOn){sem_post(&writerSem);}
    }
    if(semaOn){sem_post(&readerSem);}

}

void incrementCounter(){
    for (int i = 0; i < 100; i++) {
        counter = counter + 1;
    }
    //printf("Updating Counter: %d\n", counter);
}

void* Write(void *input){
    usleep(rand()/100000);
    int semaOn = ((struct args*)input)->semaOn;
    
    if(semaOn){sem_wait(&orderSem);}
    if(semaOn){sem_wait(&writerSem);}
    if(semaOn){sem_post(&orderSem);}

    incrementCounter();

    if(semaOn){sem_post(&writerSem);}
	
}

bool test(int totalThreadsWriters, int repetitions){
    
    return counter==totalThreadsWriters*repetitions*100;
}

int main(int argc, char* argv[]){
    clock_t begin = clock();

    sem_init(&writerSem, 0, 1);
    sem_init(&readerSem, 0, 1);
    sem_init(&orderSem, 0, 1);   

    int totalThreadsReaders = atoi(argv[1]);
    int totalThreadsWriters = atoi(argv[2]);
    int repetitions = atoi(argv[3]);
    int semaOn = atoi(argv[4]);
    
    struct args *pthreadArgs = (struct args *)malloc(sizeof(struct args));
    pthreadArgs->semaOn = semaOn;

    pthread_t th[totalThreadsReaders+totalThreadsWriters];
    
    int i;
    int j;
    for (j = 0; j < repetitions; j++) { 
    
        for (i = 0; i < totalThreadsReaders; i++) {
            if (pthread_create(th + i, NULL, &Read, (void *)pthreadArgs) != 0) {
                perror("Failed to create thread");
                return 1;
            }
        }

        for (i = 0; i < totalThreadsWriters; i++) {
            if (pthread_create(th + i + totalThreadsReaders, NULL, &Write, (void *)pthreadArgs) != 0) {
                perror("Failed to create thread");
                return 1;
            }
        }

        for (i = 0; i < totalThreadsReaders+totalThreadsWriters; i++) {
            if (pthread_join(th[i], NULL) != 0) {
                return 2;
            }
        }
    }
    sem_destroy(&writerSem);
    sem_destroy(&readerSem);
    sem_destroy(&orderSem);
    
    clock_t end = clock();
    double time_spent = (double)(end - begin) / CLOCKS_PER_SEC;
    printf("Counter result: %d \n", counter);
    printf("Time spent: %f\n", time_spent);
    printf("result: %d\n", test(totalThreadsWriters, repetitions));
    return 0;
}
